---
title: Error Handling
description: Unified error handling strategy in Bedstack.
---

Bedstack uses a centralized error handling strategy to ensure consistent API responses and simplify development.

## Centralized `onError` Handler

The main application setup in `apps/conduit/src/app.module.ts` defines a global `onError` handler for Elysia.

```typescript
export const setupApp = () => {
  return new Elysia()
    .onError(({ error, code, set }) => {
      // Handles RealWorldError, ValidationError, NotFoundError, etc.
    });
}
```

## `RealWorldError`

For manual error throwing in services or controllers, use the `RealWorldError` class. This class follows the RealWorld specification for error responses.

```typescript
import { RealWorldError } from '@/shared/errors';
import { StatusCodes } from 'http-status-codes';

throw new RealWorldError(StatusCodes.UNPROCESSABLE_ENTITY, {
  email: ['has already been taken'],
});
```

### Response Format

The resulting JSON response will be:

```json
{
  "errors": {
    "email": ["has already been taken"]
  }
}
```

## Formatted Validation Errors

Bedstack automatically converts validation errors (from ArkType or Elysia) into the RealWorld error format.

If a body fails validation:
- Path `/user/username` becomes `user.username`.
- Messages are cleaned up to be concise (e.g., "should be at least 8 characters").

## Database Errors

Generic database errors are caught and logged, returning a generic `500 Internal Server Error` style response to the client to avoid leaking sensitive information.

```typescript
// Sample db error response
{
  "errors": {
    "database": ["error occurred"]
  }
}
```
